[
  {
    "problem": "Concurrency",
    "tags": [
      "race conditions",
      "multithreading",
      "async"
    ],
    "patterns": [
      {
        "name": "Thread Synchronization",
        "solutions": [
          {
            "name": "Mutex",
            "tool": "Java Concurrency",
            "language": "Java"
          },
          {
            "name": "Go Routines + Channels",
            "tool": "Golang",
            "language": "Go"
          },
          {
            "name": "async/await",
            "tool": "Node.js",
            "language": "JavaScript"
          }
        ]
      },
      {
        "name": "Distributed Coordination",
        "solutions": [
          {
            "name": "Leader Election",
            "tool": "Zookeeper",
            "language": "Java"
          },
          {
            "name": "Distributed Locking",
            "tool": "etcd",
            "language": "Go"
          },
          {
            "name": "Redlock",
            "tool": "Redis",
            "language": "Any"
          }
        ]
      }
    ]
  },
  {
    "problem": "Information Retrieval",
    "tags": [
      "search",
      "text",
      "filter"
    ],
    "patterns": [
      {
        "name": "Inverted Index",
        "solutions": [
          {
            "name": "Elasticsearch",
            "tool": "Elastic Stack",
            "language": "Java"
          },
          {
            "name": "Meilisearch",
            "tool": "Meilisearch",
            "language": "Rust"
          },
          {
            "name": "Solr",
            "tool": "Apache Solr",
            "language": "Java"
          }
        ]
      }
    ]
  },
  {
    "problem": "Workflow Management",
    "tags": [
      "state machine",
      "process",
      "approval"
    ],
    "patterns": [
      {
        "name": "State Machine / BPMN",
        "solutions": [
          {
            "name": "Camunda",
            "tool": "BPM Platform",
            "language": "Java"
          },
          {
            "name": "Temporal.io",
            "tool": "Workflow Engine",
            "language": "Go/Java/TS"
          },
          {
            "name": "AWS Step Functions",
            "tool": "AWS",
            "language": "JSON DSL"
          }
        ]
      }
    ]
  },
  {
    "problem": "Search & Filtering",
    "tags": [
      "query",
      "filter",
      "ranking"
    ],
    "patterns": [
      {
        "name": "Faceted Search",
        "solutions": [
          {
            "name": "Elasticsearch",
            "tool": "Elastic Stack",
            "language": "Java"
          },
          {
            "name": "Algolia",
            "tool": "Algolia",
            "language": "JS/TS SDK"
          }
        ]
      }
    ]
  },
  {
    "problem": "Data Transformation",
    "tags": [
      "ETL",
      "batch",
      "pipeline"
    ],
    "patterns": [
      {
        "name": "Batch Processing",
        "solutions": [
          {
            "name": "Apache Spark",
            "tool": "Apache",
            "language": "Scala/Java/Py"
          },
          {
            "name": "Airflow",
            "tool": "Apache",
            "language": "Python"
          },
          {
            "name": "dbt",
            "tool": "Transform Tool",
            "language": "SQL"
          }
        ]
      }
    ]
  },
  {
    "problem": "Stream Processing",
    "tags": [
      "event",
      "real-time",
      "stream"
    ],
    "patterns": [
      {
        "name": "Event-Driven Architecture",
        "solutions": [
          {
            "name": "Kafka",
            "tool": "Apache",
            "language": "Java"
          },
          {
            "name": "Kinesis",
            "tool": "AWS",
            "language": "Python/Java"
          },
          {
            "name": "NATS",
            "tool": "NATS.io",
            "language": "Go"
          }
        ]
      }
    ]
  },
  {
    "problem": "Caching",
    "subcategory": "In-memory key-value",
    "tags": [
      "cache",
      "latency",
      "throughput",
      "TTL"
    ],
    "patterns": [
      {
        "name": "Application & Edge Caching",
        "solutions": [
          {
            "name": "Redis",
            "tool": "Redis",
            "language": "Any"
          },
          {
            "name": "Memcached",
            "tool": "Memcached",
            "language": "Any"
          },
          {
            "name": "CDN",
            "tool": "Cloudflare/Akamai",
            "language": "HTTP/Edge"
          }
        ]
      }
    ],
    "examples": [
      "Session storage",
      "Hot query acceleration"
    ]
  },
  {
    "problem": "Authentication & Security",
    "tags": [
      "auth",
      "security",
      "crypto"
    ],
    "patterns": [
      {
        "name": "Token-Based Auth",
        "solutions": [
          {
            "name": "OAuth2",
            "tool": "Auth Standard",
            "language": "Any"
          },
          {
            "name": "JWT",
            "tool": "JWT.io",
            "language": "Any"
          },
          {
            "name": "SAML",
            "tool": "SAML Protocol",
            "language": "XML"
          }
        ]
      },
      {
        "name": "Hashing & Encryption",
        "solutions": [
          {
            "name": "bcrypt",
            "tool": "bcrypt-lib",
            "language": "Any"
          },
          {
            "name": "OpenSSL",
            "tool": "OpenSSL",
            "language": "C/CLI"
          }
        ]
      }
    ]
  },
  {
    "problem": "Machine Learning",
    "tags": [
      "classification",
      "prediction",
      "clustering"
    ],
    "patterns": [
      {
        "name": "Model Training",
        "solutions": [
          {
            "name": "scikit-learn",
            "tool": "Python ML",
            "language": "Python"
          },
          {
            "name": "TensorFlow",
            "tool": "Google",
            "language": "Python"
          },
          {
            "name": "PyTorch",
            "tool": "Meta",
            "language": "Python"
          }
        ]
      }
    ]
  },
  {
    "problem": "CRUD & Data Modeling",
    "subcategory": "Relational DB, ORM",
    "tags": [
      "database",
      "ORM",
      "SQL",
      "CRUD"
    ],
    "patterns": [
      {
        "name": "Relational Database Access",
        "solutions": [
          {
            "name": "PostgreSQL",
            "tool": "PostgreSQL",
            "language": "SQL"
          },
          {
            "name": "MySQL",
            "tool": "MySQL",
            "language": "SQL"
          },
          {
            "name": "MS SQL",
            "tool": "Microsoft SQL Server",
            "language": "SQL"
          },
          {
            "name": "Hibernate",
            "tool": "Hibernate ORM",
            "language": "Java"
          },
          {
            "name": "Sequelize",
            "tool": "Sequelize ORM",
            "language": "JavaScript/TypeScript"
          }
        ]
      }
    ],
    "examples": [
      "E-commerce product databases",
      "User profiles"
    ]
  },
  {
    "problem": "Workflow / FSM",
    "subcategory": "State transitions, approvals",
    "tags": [
      "workflow",
      "state-machine",
      "BPMN",
      "approvals"
    ],
    "patterns": [
      {
        "name": "Workflow Automation / FSM",
        "solutions": [
          {
            "name": "Camunda",
            "tool": "Camunda BPM",
            "language": "Java"
          },
          {
            "name": "Zeebe",
            "tool": "Zeebe Workflow",
            "language": "Java"
          },
          {
            "name": "AWS Step Functions",
            "tool": "AWS",
            "language": "JSON DSL"
          },
          {
            "name": "Temporal",
            "tool": "Temporal.io",
            "language": "Go/Java/TypeScript"
          }
        ]
      }
    ],
    "examples": [
      "Order lifecycle",
      "Insurance claim approval"
    ]
  },
  {
    "problem": "Stream/Event Processing",
    "subcategory": "Real-time, event-driven",
    "tags": [
      "stream",
      "events",
      "real-time",
      "EDA"
    ],
    "patterns": [
      {
        "name": "Event Streaming",
        "solutions": [
          {
            "name": "Kafka",
            "tool": "Apache Kafka",
            "language": "Java"
          },
          {
            "name": "RabbitMQ",
            "tool": "RabbitMQ",
            "language": "Any"
          },
          {
            "name": "Kinesis",
            "tool": "AWS Kinesis",
            "language": "Python/Java"
          },
          {
            "name": "NATS",
            "tool": "NATS",
            "language": "Go"
          }
        ]
      }
    ],
    "examples": [
      "Audit logs",
      "Notifications",
      "Metrics pipelines"
    ]
  },
  {
    "problem": "Batch/ETL Processing",
    "subcategory": "Scheduled jobs, transforms",
    "tags": [
      "batch",
      "ETL",
      "scheduling",
      "transform"
    ],
    "patterns": [
      {
        "name": "Batch Orchestration",
        "solutions": [
          {
            "name": "Apache Airflow",
            "tool": "Airflow",
            "language": "Python"
          },
          {
            "name": "Apache Spark",
            "tool": "Spark",
            "language": "Scala/Java/Python"
          },
          {
            "name": "Pandas",
            "tool": "pandas",
            "language": "Python"
          },
          {
            "name": "dbt",
            "tool": "dbt",
            "language": "SQL"
          }
        ]
      }
    ],
    "examples": [
      "Daily reports",
      "Nightly imports",
      "Billing"
    ]
  },
  {
    "problem": "Search / Retrieval",
    "subcategory": "Full-text, faceted, ranked",
    "tags": [
      "search",
      "retrieval",
      "inverted-index",
      "facets"
    ],
    "patterns": [
      {
        "name": "Search Indexing",
        "solutions": [
          {
            "name": "Elasticsearch",
            "tool": "Elastic Stack",
            "language": "Java"
          },
          {
            "name": "Solr",
            "tool": "Apache Solr",
            "language": "Java"
          },
          {
            "name": "Meilisearch",
            "tool": "Meilisearch",
            "language": "Rust"
          }
        ]
      }
    ],
    "examples": [
      "Site search",
      "Filtering",
      "Autocomplete"
    ]
  },
  {
    "problem": "Concurrency / Parallelism",
    "subcategory": "Threads, async, locking",
    "tags": [
      "concurrency",
      "parallel",
      "threading",
      "async"
    ],
    "patterns": [
      {
        "name": "Synchronization & Async",
        "solutions": [
          {
            "name": "Java Concurrency",
            "tool": "java.util.concurrent",
            "language": "Java"
          },
          {
            "name": "Go routines",
            "tool": "goroutines/channels",
            "language": "Go"
          },
          {
            "name": "Node async",
            "tool": "async/await",
            "language": "JavaScript/TypeScript"
          }
        ]
      }
    ],
    "examples": [
      "Web servers",
      "Schedulers",
      "Job queues"
    ]
  },
  {
    "problem": "Security & Crypto",
    "subcategory": "Auth, hashing, encryption",
    "tags": [
      "auth",
      "JWT",
      "OAuth2",
      "encryption",
      "hashing"
    ],
    "patterns": [
      {
        "name": "Authentication",
        "solutions": [
          {
            "name": "JWT",
            "tool": "JWT",
            "language": "Any"
          },
          {
            "name": "OAuth2",
            "tool": "OAuth2",
            "language": "Any"
          }
        ]
      },
      {
        "name": "Cryptography",
        "solutions": [
          {
            "name": "bcrypt",
            "tool": "bcrypt",
            "language": "Any"
          },
          {
            "name": "OpenSSL",
            "tool": "OpenSSL",
            "language": "C/CLI"
          }
        ]
      }
    ],
    "examples": [
      "Login systems",
      "Encrypted storage",
      "Secure APIs"
    ]
  },
  {
    "problem": "Scheduling / Optimization",
    "subcategory": "Approximate or exact solvers",
    "tags": [
      "optimization",
      "LP",
      "ILP",
      "CP-SAT",
      "heuristics"
    ],
    "patterns": [
      {
        "name": "Solvers & Heuristics",
        "solutions": [
          {
            "name": "Google OR-Tools",
            "tool": "OR-Tools",
            "language": "C++/Python/Java"
          },
          {
            "name": "OptaPlanner",
            "tool": "OptaPlanner",
            "language": "Java"
          },
          {
            "name": "Custom heuristics",
            "tool": "Heuristics",
            "language": "Any"
          }
        ]
      }
    ],
    "examples": [
      "Room booking",
      "Delivery windows"
    ]
  },
  {
    "problem": "Machine Learning / AI",
    "subcategory": "Classification, clustering",
    "tags": [
      "ML",
      "AI",
      "classification",
      "clustering",
      "NLP"
    ],
    "patterns": [
      {
        "name": "Modeling Frameworks",
        "solutions": [
          {
            "name": "TensorFlow",
            "tool": "TensorFlow",
            "language": "Python"
          },
          {
            "name": "PyTorch",
            "tool": "PyTorch",
            "language": "Python"
          },
          {
            "name": "scikit-learn",
            "tool": "scikit-learn",
            "language": "Python"
          },
          {
            "name": "HuggingFace",
            "tool": "Transformers",
            "language": "Python"
          }
        ]
      }
    ],
    "examples": [
      "Fraud detection",
      "Recommendations",
      "Churn prediction"
    ]
  },
  {
    "problem": "Graph Algorithms",
    "subcategory": "Traversal, shortest path",
    "tags": [
      "graph",
      "traversal",
      "shortest-path"
    ],
    "patterns": [
      {
        "name": "Graph Processing",
        "solutions": [
          {
            "name": "Neo4j",
            "tool": "Neo4j",
            "language": "Cypher"
          },
          {
            "name": "Gremlin",
            "tool": "TinkerPop Gremlin",
            "language": "Gremlin"
          },
          {
            "name": "NetworkX",
            "tool": "NetworkX",
            "language": "Python"
          }
        ]
      }
    ],
    "examples": [
      "Social networks",
      "Logistics",
      "Org hierarchies"
    ]
  },
  {
    "problem": "Constraint Solving",
    "subcategory": "Valid configurations",
    "tags": [
      "constraints",
      "CSP",
      "SAT",
      "optimization"
    ],
    "patterns": [
      {
        "name": "Constraint Programming",
        "solutions": [
          {
            "name": "Z3",
            "tool": "Z3 Theorem Prover",
            "language": "C#/Python"
          },
          {
            "name": "Gurobi",
            "tool": "Gurobi",
            "language": "Python/Java/C++"
          },
          {
            "name": "OR-Tools CP-SAT",
            "tool": "OR-Tools",
            "language": "C++/Python/Java"
          },
          {
            "name": "MiniZinc",
            "tool": "MiniZinc",
            "language": "Modeling language"
          }
        ]
      }
    ],
    "examples": [
      "CPQ",
      "Test scheduling"
    ]
  },
  {
    "problem": "Formal Verification",
    "subcategory": "Correctness proof, model check",
    "tags": [
      "formal",
      "verification",
      "model-checking"
    ],
    "patterns": [
      {
        "name": "Specification & Proof",
        "solutions": [
          {
            "name": "TLA+",
            "tool": "TLA+",
            "language": "Spec language"
          },
          {
            "name": "Coq",
            "tool": "Coq",
            "language": "Gallina"
          },
          {
            "name": "Alloy",
            "tool": "Alloy",
            "language": "Alloy"
          }
        ]
      }
    ],
    "examples": [
      "Mission-critical systems",
      "Consensus protocols"
    ]
  },
  {
    "problem": "Observability",
    "subcategory": "Logging, metrics, tracing",
    "tags": [
      "observability",
      "metrics",
      "logging",
      "tracing"
    ],
    "patterns": [
      {
        "name": "Telemetry & Monitoring",
        "solutions": [
          {
            "name": "Prometheus",
            "tool": "Prometheus",
            "language": "PromQL"
          },
          {
            "name": "Grafana",
            "tool": "Grafana",
            "language": "Dashboards"
          },
          {
            "name": "ELK",
            "tool": "Elastic Stack",
            "language": "Elasticsearch/Logstash/Kibana"
          },
          {
            "name": "OpenTelemetry",
            "tool": "OpenTelemetry",
            "language": "Any"
          }
        ]
      }
    ],
    "examples": [
      "Uptime monitoring",
      "Resource usage"
    ]
  },
  {
    "problem": "Messaging / Coordination",
    "subcategory": "Distributed locks, messaging",
    "tags": [
      "coordination",
      "locks",
      "messaging",
      "discovery"
    ],
    "patterns": [
      {
        "name": "Service Coordination",
        "solutions": [
          {
            "name": "Zookeeper",
            "tool": "Apache Zookeeper",
            "language": "Java"
          },
          {
            "name": "etcd",
            "tool": "etcd",
            "language": "Go"
          },
          {
            "name": "Consul",
            "tool": "HashiCorp Consul",
            "language": "Go"
          }
        ]
      }
    ],
    "examples": [
      "Leader election",
      "Service discovery",
      "Coordination"
    ]
  },
  {
    "problem": "State-space search",
    "subcategory": "Search",
    "description": "Find path to goal through defined state transitions",
    "tags": [
      "search",
      "state-space"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Pathfinding",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "game AI",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "puzzle solvers",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Pathfinding",
      "game AI",
      "puzzle solvers"
    ]
  },
  {
    "problem": "Heuristic search",
    "subcategory": "Search",
    "description": "Use heuristics to guide search faster",
    "tags": [
      "search",
      "heuristic"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "A*",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "IDA*",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "beam search",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "A*",
      "IDA*",
      "beam search"
    ]
  },
  {
    "problem": "Linear/Integer Programming",
    "subcategory": "Optimization",
    "description": "Maximize or minimize under constraints",
    "tags": [
      "optimization",
      "linear",
      "programming",
      "integer"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Supply chain optimization",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "scheduling",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Supply chain optimization",
      "scheduling"
    ]
  },
  {
    "problem": "Greedy Algorithms",
    "subcategory": "Optimization",
    "description": "Make local optimal choices",
    "tags": [
      "optimization",
      "algorithms",
      "greedy"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Huffman coding",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "MST",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "activity selection",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Huffman coding",
      "MST",
      "activity selection"
    ]
  },
  {
    "problem": "Dynamic Programming",
    "subcategory": "Optimization",
    "description": "Break problem into overlapping subproblems",
    "tags": [
      "optimization",
      "dynamic",
      "programming"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "DP for knapsack",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "sequence alignment",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "DP for knapsack",
      "sequence alignment"
    ]
  },
  {
    "problem": "Constraint Satisfaction Problems (CSP)",
    "subcategory": "Constraint Solving",
    "description": "Satisfy logical constraints over variables",
    "tags": [
      "(csp)",
      "problems",
      "solving",
      "constraint",
      "satisfaction"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Sudoku",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "scheduling",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "Prolog-style reasoning",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Sudoku",
      "scheduling",
      "Prolog-style reasoning"
    ]
  },
  {
    "problem": "Graph traversal/search",
    "subcategory": "Graph-Based",
    "description": "Nodes/edges modeling relationships",
    "tags": [
      "search",
      "traversal",
      "graph-based",
      "graph"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "BFS",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "DFS",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "Dijkstra",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "BFS",
      "DFS",
      "Dijkstra"
    ]
  },
  {
    "problem": "Network flow",
    "subcategory": "Graph-Based",
    "description": "Optimizing flow in a network",
    "tags": [
      "network",
      "flow",
      "graph-based"
    ],
    "patterns": [
  {
    "name": "Algorithms",
    "solutions": [
      {
        "name": "Edmonds–Karp (max flow)",
        "tool": "Algorithm",
        "language": "Python",
        "blurb": "BFS-based augmenting paths (Ford–Fulkerson with BFS); O(V·E²).",
        "code": "from collections import deque\n\ndef edmonds_karp(cap, s, t):\n    # cap[u][v] = capacity; build residual graph on the fly\n    n = len(cap)\n    flow = 0\n    parent = [-1]*n\n    def bfs():\n        for i in range(n): parent[i] = -1\n        parent[s] = s\n        q = deque([s])\n        while q:\n            u = q.popleft()\n            for v in range(n):\n                if parent[v] == -1 and cap[u][v] > 0:\n                    parent[v] = u\n                    if v == t: return True\n                    q.append(v)\n        return False\n    while bfs():\n        # find bottleneck\n        v = t; bottleneck = float('inf')\n        while v != s:\n            u = parent[v]\n            bottleneck = min(bottleneck, cap[u][v])\n            v = u\n        # augment\n        v = t\n        while v != s:\n            u = parent[v]\n            cap[u][v] -= bottleneck\n            cap[v][u] += bottleneck\n            v = u\n        flow += bottleneck\n    return flow\n\n# Example usage:\n# cap is an NxN matrix; s=0, t=N-1\n# cap[u][v] = capacity from u to v; missing edges are 0\n"
      },
      {
        "name": "Dinic (max flow)",
        "tool": "Algorithm",
        "language": "Python",
        "blurb": "Level graph + blocking flow; O(E·V²) general, faster in practice.",
        "code": "from collections import deque\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.adj = [[] for _ in range(n)]\n    def add_edge(self, u, v, c):\n        self.adj[u].append([v, c, len(self.adj[v])])\n        self.adj[v].append([u, 0, len(self.adj[u])-1])\n    def maxflow(self, s, t):\n        flow = 0\n        INF = 10**18\n        while True:\n            level = [-1]*self.n\n            q = deque([s]); level[s] = 0\n            while q:\n                u = q.popleft()\n                for v, cap, rev in self.adj[u]:\n                    if cap > 0 and level[v] < 0:\n                        level[v] = level[u]+1; q.append(v)\n            if level[t] < 0: break\n            it = [0]*self.n\n            def dfs(u, f):\n                if u == t: return f\n                for i in range(it[u], len(self.adj[u])):\n                    it[u] = i\n                    v, cap, rev = self.adj[u][i]\n                    if cap > 0 and level[u] < level[v]:\n                        d = dfs(v, min(f, cap))\n                        if d:  # augment\n                            self.adj[u][i][1] -= d\n                            self.adj[v][rev][1] += d\n                            return d\n                return 0\n            while True:\n                pushed = dfs(s, INF)\n                if not pushed: break\n                flow += pushed\n        return flow\n\n# Example: build graph with add_edge(u,v,c), then run maxflow(s,t)\n"
      },
      {
        "name": "Push–relabel (max flow)",
        "tool": "Algorithm",
        "language": "",
        "blurb": "Preflow with local pushes and relabels; near-linear on many sparse graphs.",
        "url": "https://cp-algorithms.com/graph/push-relabel.html"
      }
    ]
  },
  {
    "name": "Libraries",
    "solutions": [
      {
        "name": "NetworkX maximum_flow",
        "tool": "Library",
        "language": "Python",
        "url": "https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.flow.maximum_flow.html",
        "code": "import networkx as nx\nG = nx.DiGraph()\nG.add_edge('s','a', capacity=3)\nG.add_edge('s','b', capacity=2)\nG.add_edge('a','b', capacity=1)\nG.add_edge('a','t', capacity=2)\nG.add_edge('b','t', capacity=3)\nflow_val, flow_dict = nx.maximum_flow(G, 's', 't')\nprint(flow_val)\n"
      },
      {
        "name": "OR-Tools SimpleMaxFlow",
        "tool": "Library",
        "language": "Python",
        "url": "https://developers.google.com/optimization/flow/maxflow",
        "code": "from ortools.graph.python import max_flow\nmf = max_flow.SimpleMaxFlow()\n# add arcs: (tail, head, capacity)\nmf.add_arc_with_capacity(0, 1, 3)\nmf.add_arc_with_capacity(0, 2, 2)\nmf.add_arc_with_capacity(1, 2, 1)\nmf.add_arc_with_capacity(1, 3, 2)\nmf.add_arc_with_capacity(2, 3, 3)\nstatus = mf.solve(0, 3)\nprint('max flow =', mf.optimal_flow())\n"
      },
      {
        "name": "Boost Graph (C++)",
        "tool": "Library",
        "language": "C++",
        "url": "https://www.boost.org/doc/libs/release/libs/graph/doc/maximum_flow.html",
        "blurb": "Use push_relabel_max_flow or edmonds_karp_max_flow for high-performance C++."
      }
    ]
  }
],

    "examples": [
      "Max flow / min cut",
      "bipartite matching"
    ]
  },
  {
    "problem": "CRUD / Transactional",
    "subcategory": "Data-Centric",
    "description": "Create/Read/Update/Delete of structured data",
    "tags": [
      "transactional",
      "data-centric",
      "crud"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Databases",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "record management",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Databases",
      "record management"
    ]
  },
  {
    "problem": "Stream processing",
    "subcategory": "Data-Centric",
    "description": "Process data in real-time or pipelines",
    "tags": [
      "processing",
      "data-centric",
      "stream"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Kafka consumers",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "log processing",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Kafka consumers",
      "log processing"
    ]
  },
  {
    "problem": "Batch processing",
    "subcategory": "Data-Centric",
    "description": "Operate on large static datasets",
    "tags": [
      "batch",
      "processing",
      "data-centric"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "MapReduce",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "ETL jobs",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "MapReduce",
      "ETL jobs"
    ]
  },
  {
    "problem": "Logic programming",
    "subcategory": "Functional / Declarative",
    "description": "Declare what should be true",
    "tags": [
      "programming",
      "logic",
      "/",
      "functional",
      "declarative"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Prolog",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "SQL",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Prolog",
      "SQL"
    ]
  },
  {
    "problem": "Functional pipelines",
    "subcategory": "Functional / Declarative",
    "description": "Data transformed by functions",
    "tags": [
      "functional",
      "pipelines",
      "declarative",
      "/"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Map/filter/reduce",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "stream transformations",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Map/filter/reduce",
      "stream transformations"
    ]
  },
  {
    "problem": "Classification / Regression",
    "subcategory": "Pattern Recognition",
    "description": "Fit models to data, ML/AI approaches",
    "tags": [
      "recognition",
      "pattern",
      "classification",
      "regression"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Spam detection",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "customer churn",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Spam detection",
      "customer churn"
    ]
  },
  {
    "problem": "Race conditions & synchronization",
    "subcategory": "Concurrency & Coordination",
    "description": "Managing parallelism & shared resources",
    "tags": [
      "coordination",
      "synchronization",
      "&",
      "concurrency",
      "race",
      "conditions"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Threading",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "mutex",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "actor model",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Threading",
      "mutex",
      "actor model"
    ]
  },
  {
    "problem": "Distributed consensus",
    "subcategory": "Concurrency & Coordination",
    "description": "Agreement across distributed systems",
    "tags": [
      "coordination",
      "&",
      "concurrency",
      "consensus",
      "distributed"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Paxos",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "Raft",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "Zookeeper",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Paxos",
      "Raft",
      "Zookeeper"
    ]
  },
  {
    "problem": "Finite State Machines (FSM)",
    "subcategory": "Modeling",
    "description": "Systems with discrete states & transitions",
    "tags": [
      "modeling",
      "machines",
      "state",
      "finite",
      "(fsm)"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "UI logic",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "protocol design",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "UI logic",
      "protocol design"
    ]
  },
  {
    "problem": "Petri nets",
    "subcategory": "Modeling",
    "description": "More complex state modeling including concurrency",
    "tags": [
      "modeling",
      "petri",
      "nets"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Workflow engines",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Workflow engines"
    ]
  },
  {
    "problem": "Formal methods & model checking",
    "subcategory": "Verification",
    "description": "Prove program correctness",
    "tags": [
      "checking",
      "methods",
      "model",
      "&",
      "formal",
      "verification"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "SAT solving",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "formal specs (Z, TLA+)",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "SAT solving",
      "formal specs (Z, TLA+)"
    ]
  },
  {
    "problem": "Encoding, hashing, encryption",
    "subcategory": "Cryptography",
    "description": "Secure communications and integrity",
    "tags": [
      "encoding,",
      "hashing,",
      "cryptography",
      "encryption"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "RSA",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "AES",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "SHA-256",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "digital signatures",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "RSA",
      "AES",
      "SHA-256",
      "digital signatures"
    ]
  },
  {
    "problem": "Search indexes, relevance ranking",
    "subcategory": "Information Retrieval",
    "description": "Retrieve most relevant documents",
    "tags": [
      "indexes,",
      "ranking",
      "relevance",
      "search",
      "information",
      "retrieval"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Elasticsearch",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "Lucene",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "Meilisearch",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Elasticsearch",
      "Lucene",
      "Meilisearch"
    ]
  },
  {
    "problem": "Stochastic or discrete-event simulation",
    "subcategory": "Simulation",
    "description": "Model behavior of systems over time",
    "tags": [
      "or",
      "simulation",
      "stochastic",
      "discrete-event"
    ],
    "patterns": [
      {
        "name": "Overview",
        "solutions": [
          {
            "name": "Monte Carlo",
            "tool": "Example",
            "language": ""
          },
          {
            "name": "queue simulation",
            "tool": "Example",
            "language": ""
          }
        ]
      }
    ],
    "examples": [
      "Monte Carlo",
      "queue simulation"
    ]
  }
]